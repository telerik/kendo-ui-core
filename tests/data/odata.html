<!DOCTYPE html>
<html>
    <head>
        <title>OData Tests</title>
        <script src="../../src/jquery.js"></script>
        <script type="text/javascript" src="../qunit.js"></script>
        <script type="text/javascript" src="../qunit-runner.js"></script>
        <script src="../../src/kendo.core.js"></script>
        <script src="../../src/kendo.data.odata.js"></script>
        <script src="../../src/kendo.data.xml.js"></script>
        <script src="../../src/kendo.data.js"></script>
        <link rel="stylesheet" href="../qunit.css" type="text/css" />
    </head>
    <body>
        <h1 id="qunit-header">OData example</h1>
        <h2 id="qunit-banner"></h2>
        <div id="qunit-testrunner-toolbar"></div>
        <h2 id="qunit-userAgent"></h2>
        <ol id="qunit-tests"></ol>
        <script>

            var dialect = kendo.data.transports["odata"].dialect;
            var DataSource = kendo.data.DataSource;

            test("datasource with type odata creates remote transport with dialect", function() {
                var dataSource = new DataSource({
                    type: "odata",
                    transport: {
                        read: "foo"
                    }
                });

                ok(dataSource.transport.dialect === dialect);
            });

            test("datasource with type odata creates remote transport and sets default values for read", function() {
                var dataSource = new DataSource({
                    type: "odata",
                    transport: {
                        read: "foo"
                    }
                });

                var read = dataSource.transport.options.read;
                equal(read.dataType, "jsonp");
                equal(read.cache, true);
                equal(read.jsonp, false);
                equal(read.jsonpCallback, "callback");
            });

            test("datasource with type odata initializes odata schema", function() {
                var dataSource = new DataSource({
                    type: "odata",
                    transport: {
                        read: "foo"
                    }
                });

                var schema = dataSource.options.schema;
                equal(schema.total, "d.__count");
                equal(schema.data, "d.results");
            });

            test("dialect adds $format and $inlinecount and $callback to the request", function() {
                equal(dialect(), "$format=json&$inlinecount=allpages&$callback=callback");
            });

            test("dialect adds $skip when skip is specified", function() {
                ok(dialect({skip: 1}).indexOf("&$skip=1") > -1 );
            });

            test("dialect does not add $skip when skip is not specified", function() {
                ok(dialect({}).indexOf("&$skip=1") === -1 );
            });

            test("dialect adds $top when take is specified", function() {
                ok(dialect({take: 1}).indexOf("&$top=1") > -1 );
            });

            test("dialect does not add $top when take is not specified", function() {
                ok(dialect({}).indexOf("&$top=1") === -1 );
            });

            test("dialect adds $orderby when sort is specified", function() {
                ok(dialect({ sort: [ { field:"foo", dir: "asc" } ]}).indexOf("&$orderby=foo") > -1 );
            });

            test("$orderby with nested field", function() {
                ok(dialect({ sort: [ { field:"foo.bar", dir: "asc" } ]}).indexOf("&$orderby=foo/bar") > -1 );
            });

            test("dialect does not add $orderby if sort is not specified", function() {
                ok(dialect({ }).indexOf("&$orderby=foo") === -1 );
            });

            test("$orderby when direction is descending", function() {
                ok(dialect({ sort: [ { field:"foo", dir: "desc" } ]}).indexOf("&$orderby=foo desc") > -1 );
            });

            test("$orderby when there are multiple order by expressions", function() {
                ok(dialect({ sort: [ { field:"bar", dir: "desc" }, { field:"foo", dir: "asc" } ]}).indexOf("&$orderby=bar desc,foo") > -1 );
            });

            test("dialect adds $filter if filter is specified", function() {
                ok(dialect({ filter: [ {field: "Name", operator: "startswith", value: "bar"} ]}).indexOf("&$filter=startswith(Name,'bar')") > -1 );
            });

            test("dialect does not add $filter if filter is not specified", function() {
                ok(dialect({}).indexOf("&$filter=") === -1 );
            });

            test("$filter and endswith operator", function() {
                ok(dialect({ filter: [ {field: "Name", operator: "endswith", value: "bar"} ]}).indexOf("&$filter=endswith(Name,'bar')") > -1 );
            });

            test("$filter and contains operator uses substringof", function() {
                ok(dialect({ filter: [ {field: "Name", operator: "contains", value: "bar"} ]}).indexOf("&$filter=substringof('bar',Name)") > -1 );
            });

            test("$filter and neq operator", function() {
                ok(dialect({ filter: [ {field: "Name", operator: "neq", value: "bar"} ]}).indexOf("&$filter=Name ne 'bar'") > -1 );
            });

            test("$filter with nested field", function() {
                ok(dialect({ filter: [ {field: "foo.bar", operator: "neq", value: "bar"} ]}).indexOf("&$filter=foo/bar ne 'bar'") > -1 );
            });

            test("$filter does not quote apostrophe when numberic value is specifed", function() {
                ok(dialect({ filter: [ {field: "ID", operator: "neq", value: 10} ]}).indexOf("&$filter=ID ne 10") > -1 );
            });

            test("$filter and null value", function() {
                ok(dialect({ filter: [ {field: "ID", operator: "neq", value: null} ]}).indexOf("&$filter=ID ne null") > -1 );
            });

            test("multipler filter expressions", function() {
                ok(dialect({ filter: [ {field: "ID", operator: "neq", value: null},{field: "ID", operator: "neq", value: null} ]}).indexOf("&$filter=ID ne null and ID ne null") > -1 );
            });
        </script>
    </body>
</html>
